# Tape task

В данном репозитории предоставлена реализация структуры, симулирующая поведение
ленты (Tape). 
Были реализованы классы:

- `tape` - сама структура ленты с базовым набором команд.
- `tape_config` - класс, реализующий хранение полей, который задаются в специальном конфигурационном файле.
- `tape_exception` - свой класс ошибок.
- `cfg_parser` - парсер конфигурационного файла
- `tmp_path_creator` - вспомогательный класс, который создает папку со временными файлами в начале запуска, и удаляет её и все содержимое в конце.
- `tape_algo` - класс, содержащий расширенный набор функций для работы с `tape`. В том числе там и находится метод сортировки `tape_algo::sort`.

## Тесты

Тесты сделаны с помощью библиотеки `gootle-test`, они проверяют работу классов: `tape`, `cfg_parser` и `tape_algo`.

В папке `/tests` находится `.cpp` файл с тестами, а также две папки с исходными для тестов данными.

## Замечания касательно реализации

- Я убрал `copy-constructor` и `copy assign operator` у ленты, потому как мне захотелось оставить
интерфейс работы с этим классом примитивным. Впоследствии я реализовал копирование,
но с помощью специальной функции, которая делает нечто иное, нежели вышеописанные методы.
- Я использовал бинарные файлы вместо `.txt` при хранении данных ленты,
потому как это экономнее и с этим проще работать (кроме ввода из текстового редактора). 
Но консольное приложение принимает на вход `.txt` и выводит `.txt` файл.
- Также конфигурационные файлы представляют собой текстовые файлы,
содержащие строки `key=value`.
- `const tape` не может менять положение головы, так как это часть состояния ленты.
  (Обычный `tape`, разумеется, может).

## Сортировка

Реализована сортировка `merge-sort`, с некоторыми изменениями. Во время сортировки используется 2 дополнительных ленты (3 всего).

Хочется доказать, что сортировка действительно работает
~~оптимально~~ нормально, а именно за _O(n logn)_. 
Достаточно доказать, что `merge` работает за адекватное время, тогда
будет очевидно, что и весь `merge-sort` работает нормально.
Алгоритм работы примерно следующий: давайте будем сливать полуинтервал
**[L, R)** прямо "на месте" - в памяти сортируемой ленты,
будем предполагать, что голова ленты находится в **L**,
запишем в первую временную ленту кусок **[L, M)**,
а во вторую **[M, R)**, где **M = (L + R) / 2**. Во время этих записей
мы сдвинем голову примерно **2 (R - L)** раз. Потом сольем две половины еще
за **2 (R - L)** сдвигов наивным алгоритмом. Таким образом мы сделали
`merge` за примерно **4 (R - L)** сдвигов.

